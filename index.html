<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Chess Arena Pro+</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' fill='%23121212'/><text x='16' y='22' font-size='20' text-anchor='middle' fill='%237cb342'>♔</text></svg>">

<!-- LIBS -->
<link rel="stylesheet"
href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

<!-- UI -->
<style>

:root{
 --bg:#121212;
 --panel:#1c1c1c;
 --accent:#7cb342;
 --text:#fff;
 --muted:#aaa;
}

body{
 margin:0;
 background:var(--bg);
 color:var(--text);
 font-family:Segoe UI,Arial;
}

.app{
 display:grid;
 grid-template-columns:260px 1fr 300px;
 min-height:100vh;
 gap:15px;
 padding:15px;
}


/* LEFT PANEL */

.sidebar{
 background:var(--panel);
 border-radius:12px;
 padding:15px;
 display:flex;
 flex-direction:column;
 gap:10px;
}

.logo{
 font-size:22px;
 font-weight:700;
 text-align:center;
 color:var(--accent);
}

.btn{
 background:#2b2b2b;
 border:none;
 color:white;
 padding:10px;
 border-radius:8px;
 cursor:pointer;
 font-weight:600;
 transition:.2s;
}

.btn:hover{
 background:var(--accent);
 color:black;
}

.btn.primary{
 background:var(--accent);
 color:black;
}


/* CENTER */

.center{
 display:flex;
 flex-direction:column;
 align-items:center;
 gap:10px;
}

#board{
 width:480px;
 max-width:90vw;
}

.status{
 background:var(--panel);
 padding:10px;
 border-radius:8px;
 width:100%;
 text-align:center;
}


/* RIGHT */

.panel{
 background:var(--panel);
 border-radius:12px;
 padding:12px;
 display:flex;
 flex-direction:column;
}

.panel h3{
 margin:5px 0;
 font-size:14px;
 color:var(--muted);
 text-transform:uppercase;
}

#moves{
 flex:1;
 overflow:auto;
 font-size:14px;
}

.move{
 padding:4px;
 border-bottom:1px solid #333;
}

.review{
 flex:1;
 overflow:auto;
 font-size:13px;
 color:#ffd54f;
}


/* MULTI */

.multiBox{
 background:#222;
 padding:8px;
 border-radius:6px;
 font-size:13px;
}

input{
 width:100%;
 padding:6px;
 border-radius:6px;
 border:none;
 background:#333;
 color:white;
}

.ratingBox{
 margin-top:8px;
 padding:10px;
 background:#252525;
 border-radius:8px;
}
.ratingLabel{
 display:block;
 font-size:12px;
 color:var(--muted);
 margin-bottom:6px;
}
.ratingRow{
 display:flex;
 align-items:center;
 gap:10px;
}
.eloSlider{
 flex:1;
 min-width:0;
 height:8px;
 -webkit-appearance:none;
 appearance:none;
 background:#333;
 border-radius:4px;
}
.eloSlider::-webkit-slider-thumb{
 -webkit-appearance:none;
 width:18px;
 height:18px;
 border-radius:50%;
 background:var(--accent);
 cursor:grab;
}
.eloSlider::-moz-range-thumb{
 width:18px;
 height:18px;
 border-radius:50%;
 background:var(--accent);
 cursor:grab;
 border:none;
}
.rating{
 font-weight:700;
 color:var(--accent);
 min-width:44px;
 text-align:right;
}
.ratingHint{
 font-size:11px;
 color:#666;
 margin-top:4px;
}
.engineBox{
 margin-top:8px;
 padding:8px;
 background:#252525;
 border-radius:8px;
 font-size:12px;
}
.engineStatus{ color:var(--muted); }
.engineStatus.ready{ color:var(--accent); }
.engineStatus.fail{ color:#f44336; }
.btnSmall{ padding:6px 10px; font-size:12px; margin-top:6px; }


@media(max-width:900px){
 .app{
  grid-template-columns:1fr;
 }
}

</style>
</head>

<body>

<div class="app">

<!-- LEFT -->

<div class="sidebar">

<div class="logo">♟ Chess Arena Pro+</div>

<button class="btn primary" id="aiBtn">Play vs AI</button>
<button class="btn" id="localBtn">Local Multiplayer</button>

<button class="btn" id="analyzeBtn">Analyze Game</button>
<button class="btn" id="newBtn">New Game</button>

<button class="btn" id="saveBtn">Save</button>
<button class="btn" id="loadBtn">Load</button>


<div class="multiBox">

<b>Online Multiplayer</b><br><br>

Your ID:
<div id="myId">...</div><br>

<input id="peerId" placeholder="Opponent ID">

<button class="btn" id="connectBtn">Connect</button>

</div>


<div class="ratingBox">
 <label class="ratingLabel">AI strength (ELO)</label>
 <div class="ratingRow">
  <input type="range" id="eloSlider" min="400" max="2800" step="100" value="1200" class="eloSlider">
  <span id="rating" class="rating">1200</span>
 </div>
 <div class="ratingHint">Drag to set difficulty (400–2800)</div>
</div>

<div class="engineBox">
 <span id="engineStatus" class="engineStatus">Engine: loading…</span>
 <button type="button" class="btn btnSmall" id="engineRetryBtn" style="display:none">Reload engine</button>
</div>

</div>


<!-- CENTER -->

<div class="center">

<div class="status" id="status">
Welcome
</div>

<div id="board"></div>

</div>


<!-- RIGHT -->  

<div class="panel">

<h3>Moves</h3>
<div id="moves"></div>

<h3>Review</h3>
<div class="review" id="review"></div>

</div>

</div>



<script>
/* ======================
   GAME
====================== */

let game = new Chess();
let board;

let mode="ai"; // ai, local, online

let playerColor="w";


/* ======================
   RATING (draggable ELO = AI strength)
====================== */

let elo = Math.min(2800, Math.max(400, Number(localStorage.getItem("elo")) || 1200));

const eloSlider = document.getElementById("eloSlider");
const ratingEl = document.getElementById("rating");

function setEloDisplay(v) {
 elo = Math.min(2800, Math.max(400, Number(v)));
 eloSlider.value = elo;
 ratingEl.innerText = elo;
 localStorage.setItem("elo", String(elo));
}

eloSlider.value = elo;
ratingEl.innerText = elo;
eloSlider.addEventListener("input", () => setEloDisplay(eloSlider.value));


/* ======================
   STOCKFISH - FIXED VERSION
====================== */

let sf, ready = false, busy = false, resolveSF;

function sfSend(cmd) {
 if (!sf) return;
 // Send as plain string - standard UCI protocol
 sf.postMessage(cmd);
}

function onSFMessage(e) {
 const line = (typeof e.data === "string" ? e.data : String(e.data || "")).trim();
 if (!line) return;
 
 console.log("SF:", line); // Debug logging
 
 if (line === "uciok") {
  sfSend("isready");
  return;
 }
 if (line === "readyok") {
  ready = true;
  return;
 }
 if (line.startsWith("bestmove")) {
  const parts = line.split(/\s+/);
  const move = parts[1] || null;
  if (typeof resolveSF === "function") resolveSF(move);
  busy = false;
 }
}

function setEngineStatus(cls, text) {
 const el = document.getElementById("engineStatus");
 const retry = document.getElementById("engineRetryBtn");
 if (el) {
  el.className = "engineStatus " + (cls || "");
  el.textContent = text;
 }
 if (retry) {
  retry.style.display = (cls === "fail") ? "inline-block" : "none";
 }
}

let sfInitPromise = null;

function initSF() {
 ready = false;
 busy = false;
 resolveSF = null;
 
 try {
  if (sf) sf.terminate();
 } catch {}
 
 // Use stockfish.js (non-wasm version) for better compatibility
 const url = "https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js";
 const code = `importScripts("${url}")`;
 const blob = new Blob([code]);
 const blobUrl = URL.createObjectURL(blob);
 
 sf = new Worker(blobUrl);
 
 sf.onerror = (err) => {
  console.error("Stockfish worker error:", err);
  setEngineStatus("fail", "Engine: failed");
  ready = false;
 };
 
 sf.onmessage = onSFMessage;
 
 // Initialize UCI
 sfSend("uci");
}

async function ensureSF() {
 if (ready) return;
 if (sfInitPromise) return sfInitPromise;
 
 setEngineStatus("", "Engine: loading…");
 
 sfInitPromise = new Promise((resolve, reject) => {
  initSF();
  
  const timeout = setTimeout(() => {
   if (!ready) {
    setEngineStatus("fail", "Engine: timeout");
    reject(new Error("Engine timeout"));
   }
  }, 15000);
  
  const checkReady = setInterval(() => {
   if (ready) {
    clearInterval(checkReady);
    clearTimeout(timeout);
    setEngineStatus("ready", "Engine: ready");
    resolve();
   }
  }, 100);
 });
 
 return sfInitPromise;
}

// Start loading immediately
ensureSF().catch(() => {});

function clampEloForSF(e) {
 return Math.min(3190, Math.max(1320, Math.round(e)));
}

async function sfMove(fen) {
 await ensureSF();
 
 return new Promise(res => {
  if (busy) return res(null);
  busy = true;
  resolveSF = (uci) => {
   busy = false;
   res(uci);
  };
  
  const uciElo = clampEloForSF(elo);
  const movetimeMs = Math.min(200, Math.max(80, 80 + (elo - 400) / 12));
  
  sfSend("ucinewgame");
  sfSend("setoption name Threads value 1");
  sfSend("setoption name UCI_LimitStrength value true");
  sfSend("setoption name UCI_Elo value " + uciElo);
  sfSend("position fen " + fen);
  sfSend("go movetime " + Math.round(movetimeMs));
  
  // Timeout fallback
  setTimeout(() => {
   if (busy) {
    busy = false;
    res(null);
   }
  }, movetimeMs + 5000);
 });
}


/* ======================
   PEER (ONLINE)
====================== */

let peer=null, conn=null;

try {
 peer = new Peer();
 peer.on("open", id => { document.getElementById("myId").innerText = id; });
 peer.on("connection", c => {
  conn = c;
  setupConn();
  mode = "online";
  playerColor = "b";
  reset();
 });
} catch (e) {
 console.warn("Peer failed", e);
 document.getElementById("myId").innerText = "(offline)";
}


function setupConn(){

 conn.on("data",d=>{

  if(d.type==="move"){

   game.move(d.move);

   board.position(game.fen());

   update();
   checkEnd();
  }

  if(d.type==="new"){
   reset();
  }
 });
}


/* ======================
   BOARD
====================== */

function onDragStart(s,p){

 if(game.game_over()) return false;

 if(mode==="ai" && p[0]==="b") return false;

 if(mode==="online" && p[0]!==playerColor)
  return false;
}


function onDrop(s,t){

 let m=game.move({
  from:s,
  to:t,
  promotion:"q"
 });

 if(!m) return "snapback";


 if(mode==="online"){
  conn.send({type:"move",move:m});
 }


 update();
 updateMoves();

 if(mode==="ai" && !game.game_over()){
  setTimeout(aiMove,200);
 }

 checkEnd();
}


board=Chessboard("board",{
 draggable:true,
 position:"start",
 onDragStart,
 onDrop,
 onSnapEnd:()=>board.position(game.fen()),
 pieceTheme:
 "https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png"
});


/* ======================
   AI
====================== */

async function aiMove(){
 if (game.game_over()) return;
 document.getElementById("status").innerText = "AI thinking…";
 const fen = game.fen();
 let uci = null;
 try {
  uci = await sfMove(fen);
 } catch (e) {
  console.warn("AI move failed", e);
  const msg = (e && e.message) ? e.message : String(e);
  if (msg.includes("timeout")) {
   document.getElementById("status").innerText = "Engine still loading… please wait and try again";
  } else {
   document.getElementById("status").innerText =
    "Engine failed to load. Please reload the page.";
  }
  return;
 }

 if (!uci || uci === "(none)" || uci.length < 4) return;

 const from = uci.slice(0, 2);
 const to = uci.slice(2, 4);
 const moveObj = { from, to };
 if (uci.length >= 5) moveObj.promotion = uci[4].toLowerCase();

 const m = game.move(moveObj);
 if (!m) return;

 board.position(game.fen());
 update();
 updateMoves();
 checkEnd();
}


/* ======================
   UI
====================== */

function update(){

 let s="";

 if(game.in_checkmate())
  s="Checkmate";

 else if(game.in_draw())
  s="Draw";

 else
  s=(game.turn()=="w"?"White":"Black")+" to move";

 document.getElementById("status").innerText=s;
}


function updateMoves(){

 let h=game.history({verbose:true});

 let box=document.getElementById("moves");

 box.innerHTML="";

 for(let i=0;i<h.length;i+=2){

  let d=document.createElement("div");

  d.className="move";

  d.innerText=
   (i/2+1)+". "+
   (h[i]?.san||"")+" "+
   (h[i+1]?.san||"");

  box.appendChild(d);
 }

 box.scrollTop=99999;
}


/* ======================
   ANALYSIS
====================== */

async function analyze(){

 let hist=game.history({verbose:true});

 if(!hist.length) return alert("No game");

 let temp=new Chess();

 let review=document.getElementById("review");

 review.innerHTML="Analyzing...<br>";


 for(let i=0;i<hist.length;i++){

  let prev=temp.fen();

  temp.move(hist[i]);

  let best=null;
  try{
   best=await sfMove(prev);
  }catch(e){
   alert("Engine not available for analysis");
   break;
  }

  if(!best) continue;

  let test=new Chess(prev);

  const moveObj = { from: best.slice(0,2), to: best.slice(2,4) };
  if (best && best.length >= 5) moveObj.promotion = best[4].toLowerCase();
  test.move(moveObj);


  if(test.fen()!=temp.fen()){

   review.innerHTML+=
    "Move "+(i+1)+
    " ("+hist[i].san+") mistake<br>";
  }
 }

 review.innerHTML+="Done ✔";
}


/* ======================
   SAVE / LOAD
====================== */

function saveGame(){

 localStorage.setItem("pgn",game.pgn());
 alert("Saved");
}

function loadGame(){

 let p=localStorage.getItem("pgn");

 if(!p) return alert("No save");

 game.load_pgn(p);

 board.position(game.fen());

 update();
 updateMoves();
}


/* ======================
   RATING
====================== */

function updateElo(res){
 const K=24;
 const opp=1500;
 const exp=1/(1+Math.pow(10,(opp-elo)/400));
 const s= res==="win"?1 : res==="draw"?0.5 : 0;
 elo=Math.round(elo+K*(s-exp));
 elo=Math.min(2800,Math.max(400,elo));
 localStorage.setItem("elo",String(elo));
 eloSlider.value=elo;
 ratingEl.innerText=elo;
}


/* ======================
   END
====================== */

function checkEnd(){

 if(!game.game_over()) return;

 let r="draw";

 if(game.in_checkmate()){
  if(game.turn()=="w") r="loss";
  else r="win";
 }

 if(mode==="ai") updateElo(r);

 alert("Game Over: "+r);
}


/* ======================
   CONTROLS
====================== */

function reset(){

 game.reset();

 board.position("start");

 update();
 updateMoves();

 document.getElementById("review").innerHTML="";

 if(mode==="online" && conn){
  conn.send({type:"new"});
 }
}


document.getElementById("aiBtn").onclick=()=>{
 mode="ai";
 playerColor="w";
 reset();
};

document.getElementById("localBtn").onclick=()=>{
 mode="local";
 reset();
};

document.getElementById("newBtn").onclick=reset;

document.getElementById("saveBtn").onclick=saveGame;

document.getElementById("loadBtn").onclick=loadGame;

document.getElementById("analyzeBtn").onclick=analyze;


document.getElementById("connectBtn").onclick=()=>{
 const id=document.getElementById("peerId").value.trim();
 if(!id) return alert("Enter opponent ID");
 if(!peer) return alert("Online multiplayer not available");
 conn=peer.connect(id);
 conn.on("open",()=>{
  setupConn();
  mode="online";
  playerColor="w";
  reset();
 });
};

document.getElementById("engineRetryBtn").onclick=()=>{
 sfInitPromise=null; ready=false;
 try{ if(sf) sf.terminate(); }catch{}
 sf=null;
 setEngineStatus("","Engine: loading…");
 ensureSF().catch(()=>{});
};

update();

</script>
</body>
</html> 
